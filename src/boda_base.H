#ifndef BODA_BASE_H
#define BODA_BASE_H

#include<cassert>
#include<boost/shared_ptr.hpp>
#include<fstream>
#include<string>
#include<vector>
#include<map>
#include<set>
#include<exception>
#include<boost/integer_traits.hpp>

# define assert_st(expr)							\
  ((expr)								\
   ? __ASSERT_VOID_CAST (0)						\
   : __assert_fail ((std::string(" failed:\n") + __STRING(expr)+\
		     "\n "+stacktrace_str( get_backtrace(), 0 )).c_str(),	\
		    __FILE__, __LINE__, __ASSERT_FUNCTION))
namespace boost {
  namespace filesystem3 {
    struct path;
  }
  namespace iostreams {
    struct mapped_file;
    struct mapped_file_source;
    struct mapped_file_sink;
  }
}
namespace boda
{
  struct zi_uint32_t { uint32_t v; zi_uint32_t( void ) : v(0) { } };

  uint32_t const uint32_t_const_max = boost::integer_traits< uint32_t >::const_max;
  int32_t const int32_t_const_max = boost::integer_traits< int32_t >::const_max;
  int32_t const int32_t_const_min = boost::integer_traits< int32_t >::const_min;
  uint16_t const uint16_t_const_max = boost::integer_traits< uint16_t >::const_max;
  int16_t const int16_t_const_max = boost::integer_traits< int16_t >::const_max;
  int16_t const int16_t_const_min = boost::integer_traits< int16_t >::const_min;
  uint8_t const uint8_t_const_max = boost::integer_traits< uint8_t >::const_max;
  int8_t const int8_t_const_max = boost::integer_traits< int8_t >::const_max;
  int8_t const int8_t_const_min = boost::integer_traits< int8_t >::const_min;


  using boost::shared_ptr;
  using boost::dynamic_pointer_cast;
  using boost::iostreams::mapped_file;
  using boost::iostreams::mapped_file_source;
  using boost::iostreams::mapped_file_sink;
  using std::string;
  using std::vector;
  using std::map;
  using std::set;

  // NESI types
  struct filename_t { string in; string exp; };
  typedef vector< filename_t > vect_filename_t; 
  typedef shared_ptr< filename_t > p_filename_t; 
  typedef vector< p_filename_t > vect_p_filename_t;

  // typedef uint32_t nesi_bool // TODO

  typedef vector< string > vect_string;
  typedef shared_ptr< vect_string > p_vect_string;
  typedef set< string > set_string;

  typedef map< string, zi_uint32_t > map_str_ziu32_t;

  typedef shared_ptr< void > p_void;
  typedef shared_ptr< std::istream > p_istream;
  typedef shared_ptr< std::ifstream > p_ifstream;
  p_ifstream ifs_open( string const & fn );
  typedef shared_ptr< std::ostream > p_ostream;
  typedef shared_ptr< std::ofstream > p_ofstream;
  bool ifs_getline( std::string const &fn, p_ifstream in, std::string & line );
  p_ofstream ofs_open( string const & fn );
  p_vect_string readlines_fn( string const & fn );

  typedef shared_ptr< boost::iostreams::mapped_file > p_mapped_file;
  typedef shared_ptr< boost::iostreams::mapped_file_source > p_mapped_file_source;
  typedef shared_ptr< boost::iostreams::mapped_file_sink > p_mapped_file_sink;
  p_mapped_file_source map_file_ro( std::string const & fn );

  typedef vector< void * > vect_rp_void;
  typedef shared_ptr< vect_rp_void > p_vect_rp_void;
  p_vect_rp_void get_backtrace( void );
  string stacktrace_str( p_vect_rp_void bt, uint32_t strip_frames );
  bool ensure_is_dir( string const & fn, bool const create = 0 );
  void ensure_is_regular_file( string const & fn );

  typedef vector< uint8_t > vect_uint8_t;  
  typedef shared_ptr< uint8_t > p_uint8_t;  
  typedef vector< uint32_t > vect_uint32_t;
  typedef shared_ptr< uint32_t > p_uint32_t;  
  typedef vector< float > vect_float; 
  typedef shared_ptr< float > p_float;
  typedef vector< double > vect_double; 
  typedef shared_ptr< double > p_double; 

  // ma_p == make aligned shared_ptr. note: alloc'd with posix_memaling() and has custom deleter that invokes free()
  p_uint8_t ma_p_uint8_t( size_t const num, uint32_t const a ); 
  p_float ma_p_float( size_t const num, uint32_t const a ); 
  p_double ma_p_double( size_t const num, uint32_t const a );

  // row-major dimensions holder
  // cm_ variants implicitly operate on the reversed dims list to provide column-major access
  // using less than the full # of dims uses a prefix (or suffix for the cm_ variants) of the dims
  struct dims_t : public vect_uint32_t {
    vect_uint32_t strides; // in arbitrary units (i.e. not neccessarily bytes). can be set manually.
    uint32_t tot_elems; // valid range of indexes. if strides is set manually, you must set this manually also.
    void calc_strides( void ) { // assuming no padding, i.e. unit stride for fast dim and so on
      uint32_t const sz = size();
      assert( sz );
      strides.resize( sz );
      strides[sz-1] = 1;
      for( uint32_t d = 1; d < sz; ++d ) { strides[sz-d-1] = strides[sz-d]*(*this)[sz-d]; }
      tot_elems = strides[0]*(*this)[0]; // i.e. strides[-1], size of all data, used to bounds check
    }

    uint32_t cm_ix1( uint32_t const d0i ) {
      uint32_t const sz = size(); assert( strides.size() == sz ); assert( sz > 0 ); 
      return strides[sz-1]*d0i; }
    uint32_t cm_ix2( uint32_t const d0i, uint32_t const d1i ) { 
      uint32_t const sz = size(); assert( strides.size() == sz ); assert( sz > 1 ); 
      return strides[sz-1]*d0i + strides[sz-2]*d1i; }
    uint32_t cm_ix3( uint32_t const d0i, uint32_t const d1i, uint32_t const d2i ) { 
      uint32_t const sz = size(); assert( strides.size() == sz ); assert( sz > 2 ); 
      return strides[sz-1]*d0i + strides[sz-2]*d1i + strides[sz-3]*d2i ; }
    uint32_t cm_ix4( uint32_t const d0i, uint32_t const d1i, uint32_t const d2i, uint32_t const d3i ) { 
      uint32_t const sz = size(); assert( strides.size() == sz ); assert( sz > 3 ); 
      return strides[sz-1]*d0i + strides[sz-2]*d1i + strides[sz-3]*d2i + strides[sz-4]*d3i; }

    uint32_t ix1( uint32_t const d0i ) {
      uint32_t const sz = size(); assert( strides.size() == sz ); assert( sz > 0 ); 
      return d0i*strides[0]; }
    uint32_t ix2( uint32_t const d0i, uint32_t const d1i ) { 
      uint32_t const sz = size(); assert( strides.size() == sz ); assert( sz > 1 ); 
      return d0i*strides[0] + d1i*strides[1]; }
    uint32_t ix3( uint32_t const d0i, uint32_t const d1i, uint32_t const d2i ) { 
      uint32_t const sz = size(); assert( strides.size() == sz ); assert( sz > 2 ); 
      return d0i*strides[0] + d1i*strides[1] + d2i*strides[2]; }
    uint32_t ix4( uint32_t const d0i, uint32_t const d1i, uint32_t const d2i, uint32_t const d3i ) { 
      uint32_t const sz = size(); assert( strides.size() == sz ); assert( sz > 3 ); 
      return d0i*strides[0] + d1i*strides[1] + d2i*strides[2] + d3i*strides[3]; }

    template< typename T > T & cm_at1( shared_ptr< T > p, uint32_t const d0i ) { 
      uint32_t ix = cm_ix1( d0i ); assert( ix < tot_elems ); return p.get()[ix]; }
    template< typename T > T & cm_at2( shared_ptr< T > p, uint32_t const d0i, uint32_t const d1i ) { 
      uint32_t ix = cm_ix2( d0i,d1i ); assert( ix < tot_elems ); return p.get()[ix]; }
    template< typename T > T & cm_at3( shared_ptr< T > p, uint32_t const d0i, uint32_t const d1i, uint32_t const d2i ) { 
      uint32_t ix = cm_ix3( d0i,d1i,d2i ); assert( ix < tot_elems ); return p.get()[ix]; }
    template< typename T > T & cm_at4( shared_ptr< T > p, uint32_t const d0i, uint32_t const d1i, uint32_t const d2i, uint32_t const d3i ) { 
      uint32_t ix = cm_ix4( d0i,d1i,d2i,d3i ); assert( ix < tot_elems ); return p.get()[ix]; }

    template< typename T > T & at1( shared_ptr< T > p, uint32_t const d0i ) { 
      uint32_t ix = ix1( d0i ); assert( ix < tot_elems ); return p.get()[ix]; }
    template< typename T > T & at2( shared_ptr< T > p, uint32_t const d0i, uint32_t const d1i ) { 
      uint32_t ix = ix2( d0i,d1i ); assert( ix < tot_elems ); return p.get()[ix]; }
    template< typename T > T & at3( shared_ptr< T > p, uint32_t const d0i, uint32_t const d1i, uint32_t const d2i ) { 
      uint32_t ix = ix3( d0i,d1i,d2i ); assert( ix < tot_elems ); return p.get()[ix]; }
    template< typename T > T & at4( shared_ptr< T > p, uint32_t const d0i, uint32_t const d1i, uint32_t const d2i, uint32_t const d3i ) { 
      uint32_t ix = ix4( d0i,d1i,d2i,d3i ); assert( ix < tot_elems ); return p.get()[ix]; }
  };
  //struct nda_double_t { vect_uint32_t dims; p_double d; };

  struct rt_exception : public std::exception
  {
    string err_msg;
    p_vect_rp_void bt;
    string what_str;
    rt_exception( string const & err_msg_, p_vect_rp_void bt_ );
    virtual ~rt_exception() throw () {}
    virtual char const * what( void ) const throw();
    string what_and_stacktrace( void ) const;
    int get_ret_code( void ) const;
  };
  // raise runtime error. captures stack and raises exception with
  // given string as error message. as a perf. compromise, while the
  // top frames of the stack are always captured, they are not
  // processed into a full trace at throw time.
  void rt_err( string const & err_msg ) __attribute__((noreturn));
  // like above, but assumes PyErr_Occured(). currently just calls
  // PyErr_Print() then calls rt_err(...)
  void rt_py_err( string const & err_msg ) __attribute__((noreturn));

  // for any class to have nesi support, it must inherit ": public
  // virtual nesi", and *declare* get_cinfo() (which will be generated
  // in the corresponding .nesi_gen.cc file for the class declaration)
  struct cinfo_t;
  struct nesi { virtual cinfo_t const * get_cinfo( void ) const = 0; };
  typedef shared_ptr< nesi > p_nesi;
}

#endif // BODA_BASE_H

