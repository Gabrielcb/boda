CUCL_GLOBAL_KERNEL void %(rtc_func_name)( GASQ float const * const in, // CUCL IN img:chan:y:x
					  GASQ float * const out ) // CUCL OUT blk_bline:blk_bx:blk_in_chan:blk_y:blk_x
                                                    /* conv_out */ // CUCL REF img:chan:y:x
{
  // note: dim(in.chan) == dim(out.blk_in_chan)
  // note: for out, blk_y and blk_x are in input space, but blk_bline and blk_bx are in output space. 
  // CUCL IX GLOB_ID_1D out use_dims=blk_bline:blk_bx:blk_y:blk_x
  if( %(GLOB_ID_1D_blk_bline) >= %(out_blk_bline_dim) ) { return; }

  int32_t const conv_out_line = %(GLOB_ID_1D_blk_bline)*%(tix_pels_tile_sz);
  // CUCL IX conv_out_line conv_out use_dims=img:y 

  int32_t const fi_skip_in_lines = %(conv_out_line_y)*%(stride); 
  int32_t const in_line = (%(GLOB_ID_1D_blk_y)+fi_skip_in_lines);

  int32_t const img_in_lines = (%(conv_out_y_dim) - 1)*%(stride) + %(kern_sz);

  int32_t const img_off = in_line/img_in_lines;
  int32_t const img = %(conv_out_line_img) + img_off;

  int32_t const iy = (in_line %% img_in_lines) - %(in_pad); //%(conv_out_line_y)*%(stride) + %(GLOB_ID_1D_blk_y) - %(in_pad);

  int32_t const ix = %(GLOB_ID_1D_blk_bx)*%(t_tile_sz)*%(stride) + %(GLOB_ID_1D_blk_x) - %(in_pad);
  float const * const in_off = in + img*%(in_img_sz) + iy*%(in_y_sz) + ix*%(in_x_sz);
  float * const out_off = out + %(GLOB_ID_1D_blk_bline)*%(out_blk_bline_sz) + %(GLOB_ID_1D_blk_bx)*%(out_blk_bx_sz)
    + %(GLOB_ID_1D_blk_y)*%(out_blk_y_sz) + %(GLOB_ID_1D_blk_x)*%(out_blk_x_sz);

  bool const valid = 1
    && ( iy >= 0 )
    && ( iy < %(in_y_dim) )
    && ( img < %(in_img_dim) )
    && ( ix >= 0 )
    && ( ix < %(in_x_dim) )
    ;

  for( int32_t chan = 0; chan != %(out_blk_in_chan_dim); ++chan ) {
    float v = 0.0f;
    if(  valid  ) { v = in_off[ chan*%(in_chan_sz) ]; }
    out_off[ chan*%(out_blk_in_chan_sz) ] = v;
  }
}
